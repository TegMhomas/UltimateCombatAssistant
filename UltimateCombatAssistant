/* global on sendChat getObj findObjs createObj Campaign playerIsGM sendPing */

var UltimateCombatAssistantByZrujnowany = UltimateCombatAssistantByZrujnowany || (() => {
  'use strict';

  const SCRIPT = 'UltimateCombatAssistant by Zrujnowany';
  const STATE_KEY = 'UltimateCombatAssistantByZrujnowany';
  const VERSION = '1.1.0';

  // ============================================================
  // CONDITIONS (bez Exhaustion)
  // ============================================================
  const CONDITIONS = [
    {
      key: 'Blinded',
      markerName: 'bleeding-eye',
      desc: [
        'Can‚Äôt See. You can‚Äôt see and automatically fail any ability check that requires sight.',
        'Attacks Affected. Attack rolls against you have Advantage, and your attack rolls have Disadvantage.'
      ],
      reminders: [
        'You can‚Äôt see; auto-fail checks requiring sight.',
        'Attackers have Advantage; your attacks have Disadvantage.'
      ]
    },
    {
      key: 'Charmed',
      markerName: 'broken-heart',
      desc: [
        'Can‚Äôt Harm the Charmer. You can‚Äôt attack the charmer or target the charmer with damaging abilities or magical effects.',
        'Social Advantage. The charmer has Advantage on any ability check to interact with you socially.'
      ],
      reminders: [
        'You can‚Äôt attack or damage the charmer.',
        'Charmer has Advantage on social checks against you.'
      ]
    },
    {
      key: 'Deafened',
      markerName: 'screaming',
      desc: [
        'Can‚Äôt Hear. You can‚Äôt hear and automatically fail any ability check that requires hearing.'
      ],
      reminders: [
        'You can‚Äôt hear; auto-fail checks requiring hearing.'
      ]
    },
    {
      key: 'Frightened',
      markerName: 'broken-skull',
      desc: [
        'Ability Checks and Attacks Affected. You have Disadvantage on ability checks and attack rolls while the source of fear is within line of sight.',
        'Can‚Äôt Approach. You can‚Äôt willingly move closer to the fear source.'
      ],
      reminders: [
        'Disadvantage on ability checks & attacks while fear source is in line of sight.',
        'You can‚Äôt willingly move closer to fear source.'
      ]
    },
    {
      key: 'Grappled',
      markerName: 'grab',
      desc: [
        'Speed 0. Your Speed is 0 and can‚Äôt increase.',
        'Attacks Affected. You have Disadvantage on attack rolls against any target other than the grappler.',
        'Movable. The grappler can drag or carry you when it moves, but every foot of movement costs it 1 extra foot unless you are Tiny or two or more sizes smaller than it.'
      ],
      reminders: [
        'Speed 0 (can‚Äôt increase).',
        'Disadvantage on attacks vs targets other than grappler.',
        'Grappler can drag/carry you; costs extra movement unless size difference.'
      ]
    },
    {
      key: 'Incapacitated',
      markerName: 'interdiction',
      desc: [
        'Inactive. You can‚Äôt take any action, Bonus Action, or Reaction.',
        'No Concentration. Your Concentration is broken.',
        'Speechless. You can‚Äôt speak.',
        'Surprised. If you‚Äôre Incapacitated when you roll Initiative, you have Disadvantage on the roll.'
      ],
      reminders: [
        'No Action, Bonus Action, or Reaction.',
        'Concentration ends.',
        'You can‚Äôt speak.',
        'If you roll Initiative while incapacitated: Disadvantage.'
      ]
    },
    {
      key: 'Invisible',
      markerName: 'ninja-mask',
      desc: [
        'Surprise. If you‚Äôre Invisible when you roll Initiative, you have Advantage on the roll.',
        'Concealed. You aren‚Äôt affected by any effect that requires its target to be seen unless the effect‚Äôs creator can somehow see you. Any equipment you are wearing or carrying is also concealed.',
        'Attacks Affected. Attack rolls against you have Disadvantage, and your attack rolls have Advantage. If a creature can somehow see you, you don‚Äôt gain this benefit against that creature.'
      ],
      reminders: [
        'If you roll Initiative while invisible: Advantage.',
        'Can‚Äôt be targeted by effects requiring ‚Äúseen‚Äù unless they can see you.',
        'Attacks vs you: Disadvantage; your attacks: Advantage (unless attacker can see you).'
      ]
    },
    {
      key: 'Paralyzed',
      markerName: 'pummeled',
      desc: [
        'Incapacitated. You have the Incapacitated condition.',
        'Speed 0. Your Speed is 0 and can‚Äôt increase.',
        'Saving Throws Affected. You automatically fail Strength and Dexterity saving throws.',
        'Attacks Affected. Attack rolls against you have Advantage.',
        'Automatic Critical Hits. Any attack roll that hits you is a Critical Hit if the attacker is within 5 feet of you.'
      ],
      reminders: [
        'You are Incapacitated.',
        'Speed 0 (can‚Äôt increase).',
        'Auto-fail STR & DEX saves.',
        'Attacks vs you: Advantage.',
        'Hits from within 5 ft are Critical Hits.'
      ]
    },
    {
      key: 'Petrified',
      markerName: 'frozen-orb',
      desc: [
        'Turned to Inanimate Substance. You are transformed, along with any nonmagical objects you are wearing and carrying, into a solid inanimate substance (usually stone). Your weight increases by a factor of ten, and you cease aging.',
        'Incapacitated. You have the Incapacitated condition.',
        'Speed 0. Your Speed is 0 and can‚Äôt increase.',
        'Attacks Affected. Attack rolls against you have Advantage.',
        'Saving Throws Affected. You automatically fail Strength and Dexterity saving throws.',
        'Resist Damage. You have Resistance to all damage.',
        'Poison Immunity. You have Immunity to the Poisoned condition.'
      ],
      reminders: [
        'Turned to stone/inanimate; gear included; weight √ó10; no aging.',
        'You are Incapacitated.',
        'Speed 0 (can‚Äôt increase).',
        'Attacks vs you: Advantage.',
        'Auto-fail STR & DEX saves.',
        'Resistance to all damage.',
        'Immune to Poisoned.'
      ]
    },
    {
      key: 'Poisoned',
      markerName: 'skull',
      desc: [
        'Ability Checks and Attacks Affected. You have Disadvantage on attack rolls and ability checks.'
      ],
      reminders: [
        'Disadvantage on attack rolls and ability checks.'
      ]
    },
    {
      key: 'Prone',
      markerName: 'back-pain',
      desc: [
        'Restricted Movement. Your only movement options are to crawl or to spend an amount of movement equal to half your Speed (round down) to right yourself and thereby end the condition. If your Speed is 0, you can‚Äôt right yourself.',
        'Attacks Affected. You have Disadvantage on attack rolls. An attack roll against you has Advantage if the attacker is within 5 feet of you. Otherwise, that attack roll has Disadvantage.'
      ],
      reminders: [
        'Movement: crawl or stand using half Speed (round down); can‚Äôt stand if Speed 0.',
        'Your attacks: Disadvantage.',
        'Attacks vs you: Advantage within 5 ft, otherwise Disadvantage.'
      ]
    },
    {
      key: 'Restrained',
      markerName: 'fishing-net',
      desc: [
        'Speed 0. Your Speed is 0 and can‚Äôt increase.',
        'Attacks Affected. Attack rolls against you have Advantage, and your attack rolls have Disadvantage.',
        'Saving Throws Affected. You have Disadvantage on Dexterity saving throws.'
      ],
      reminders: [
        'Speed 0 (can‚Äôt increase).',
        'Attacks vs you: Advantage; your attacks: Disadvantage.',
        'Disadvantage on DEX saves.'
      ]
    },
    {
      key: 'Stunned',
      markerName: 'lightning-helix',
      desc: [
        'Incapacitated. You have the Incapacitated condition.',
        'Saving Throws Affected. You automatically fail Strength and Dexterity saving throws.',
        'Attacks Affected. Attack rolls against you have Advantage.'
      ],
      reminders: [
        'You are Incapacitated.',
        'Auto-fail STR & DEX saves.',
        'Attacks vs you: Advantage.'
      ]
    },
    {
      key: 'Unconscious',
      markerName: 'sleepy',
      desc: [
        'Inert. You have the Incapacitated and Prone conditions, and you drop whatever you‚Äôre holding. When this condition ends, you remain Prone.',
        'Speed 0. Your Speed is 0 and can‚Äôt increase.',
        'Attacks Affected. Attack rolls against you have Advantage.',
        'Saving Throws Affected. You automatically fail Strength and Dexterity saving throws.',
        'Automatic Critical Hits. Any attack roll that hits you is a Critical Hit if the attacker is within 5 feet of you.',
        'Unaware. You‚Äôre unaware of your surroundings.'
      ],
      reminders: [
        'You are Incapacitated and Prone; drop what you hold; remain Prone after.',
        'Speed 0 (can‚Äôt increase).',
        'Attacks vs you: Advantage.',
        'Auto-fail STR & DEX saves.',
        'Hits within 5 ft are Critical Hits.',
        'Unaware of surroundings.'
      ]
    }
  ];

  // ---------- STATE ----------
  const getState = () => {
    state[STATE_KEY] = state[STATE_KEY] || {
      version: VERSION,
      effectsByToken: {}, // tokenId -> [{condKey, markerTag, rounds, isCustom}]
      lastTurnTokenId: null,
      lastTurnOrderHash: null,
      turnNonce: 0,
      autocenterByPlayer: {}
    };
    return state[STATE_KEY];
  };

  // ---------- TOKEN MARKERS ----------
  const getMarkerCatalog = () => {
    try {
      const raw = Campaign().get('token_markers');
      return JSON.parse(raw || '[]');
    } catch (e) {
      return [];
    }
  };

  const findMarkerByName = (name) => {
    const catalog = getMarkerCatalog();
    const n = String(name || '').toLowerCase();
    return catalog.find(m => String(m.name || '').toLowerCase() === n) || null;
  };

  const getMarkerDropdown = () => {
    const markers = getMarkerCatalog()
      .filter(m => m && m.name && m.tag)
      .slice()
      .sort((a, b) => String(a.name).localeCompare(String(b.name)));

    const sanitizeLabel = (s) => String(s).replace(/[|,]/g, ' ');
    const opts = markers.map(m => `${sanitizeLabel(m.name)},${m.tag}`);
    return `?{Icon|none,none|${opts.join('|')}}`;
  };

  // ---------- TURN ORDER ----------
  const readTurnOrder = () => {
    try {
      return JSON.parse(Campaign().get('turnorder') || '[]');
    } catch (e) {
      return [];
    }
  };

  const writeTurnOrder = (order) => {
    Campaign().set('turnorder', JSON.stringify(order || []));
  };

  const getCurrentTurnToken = () => {
    const order = readTurnOrder();
    if (!order.length) return null;
    const cur = order[0];
    if (!cur || !cur.id || cur.id === '-1') return null;
    return getObj('graphic', cur.id) || null;
  };

  // ---------- EFFECTS ----------
  const getTokenEffects = (tokenId) => {
    const st = getState();
    st.effectsByToken[tokenId] = st.effectsByToken[tokenId] || [];
    return st.effectsByToken[tokenId];
  };

  const setTokenEffects = (tokenId, arr) => {
    const st = getState();
    st.effectsByToken[tokenId] = arr || [];
    if (!st.effectsByToken[tokenId].length) delete st.effectsByToken[tokenId];
  };

  // ---------- STATUS MARKERS w/ COUNTER (tag@N) ----------
  const getStatusmarkersParts = (token) => {
    const cur = String(token.get('statusmarkers') || '');
    return cur ? cur.split(',').map(s => s.trim()).filter(Boolean) : [];
  };

  const baseTag = (entry) => String(entry || '').split('@')[0];

  const upsertMarkerCountdown = (token, tag, number) => {
    const parts = getStatusmarkersParts(token).filter(p => baseTag(p) !== tag);
    if (number && number > 0) parts.push(`${tag}@${number}`);
    else parts.push(tag);
    token.set('statusmarkers', parts.join(','));
  };

  const removeMarkerTag = (token, tag) => {
    const parts = getStatusmarkersParts(token).filter(p => baseTag(p) !== tag);
    token.set('statusmarkers', parts.join(','));
  };

  const recomputeMarkerForTag = (token, tag) => {
    if (!tag) return;
    const eff = getTokenEffects(token.id);
    const maxR = Math.max(...eff.filter(e => e.markerTag === tag).map(e => parseInt(e.rounds, 10) || 0), 0);
    if (maxR > 0) upsertMarkerCountdown(token, tag, maxR);
    else removeMarkerTag(token, tag);
  };

  // ---------- UI helpers ----------
  const esc = (s) =>
    String(s)
      .replace(/&/g, '&amp;').replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');

  const oneLine = (html) => String(html).replace(/\r?\n/g, ' ').replace(/\s{2,}/g, ' ').trim();

  const getTokenImg = (token) => {
    const src = token.get('imgsrc') || '';
    return src.replace(/(\/med\.png|\/max\.png)$/, '/thumb.png');
  };
  
  const whisperTo = (playerid) => {
      const p = getObj('player', playerid);
      const name = p && p.get('_displayname') ? p.get('_displayname') : null;
      return name ? `/w "${name}" ` : `/w gm `;
    };

  const getTokenDisplayName = (token) => token.get('name') || '(Unnamed)';

    const getEnemyTier = (token) => {
      // GM Notes bywajƒÖ HTML-escaped, czasem URL-encoded
      let notes = String(token.get('gmnotes') || '');
    
      try { notes = decodeURIComponent(notes); } catch (e) { /* ignore */ }
    
      notes = notes
        .replace(/<[^>]*>/g, ' ')   // usu≈Ñ HTML
        .replace(/&nbsp;/g, ' ')
        .toLowerCase();
    
      if (notes.includes('tier:miniboss') || notes.includes('miniboss')) return 'miniboss';
      if (notes.includes('tier:boss') || notes.includes('boss')) return 'boss';
      return null;
    };

  const getTokenControllers = (token) => {
    const charId = token.get('represents');
    let controlled = '';
    if (charId) {
      const ch = getObj('character', charId);
      if (ch) controlled = ch.get('controlledby') || '';
    }
    if (!controlled) controlled = token.get('controlledby') || '';
    return controlled.split(',').map(s => s.trim()).filter(Boolean);
  };

  const canPlayerControlToken = (playerid, token) => {
    if (playerIsGM(playerid)) return true;
    const ids = getTokenControllers(token);
    return ids.includes(playerid);
  };

    // ============================================================
    // AUTO-CENTER (per player) + global ping for everyone
    // ============================================================
    const isAutoCenterEnabledForPlayer = (playerid) => {
      const st = getState();
      st.autocenterByPlayer = st.autocenterByPlayer || {};
      const v = st.autocenterByPlayer[playerid];
      // domy≈õlnie ON
      return (v === undefined) ? true : !!v;
    };
    
    const pingTokenToEveryone = (token) => {
      try {
        const pageid = token.get('_pageid');
        const x = token.get('left');
        const y = token.get('top');
        // global ping -> ka≈ºdy widzi znacznik
        sendPing(x, y, pageid);
      } catch (e) { /* ignore */ }
    };
    
    const centerTokenForPlayers = (token, playerIds) => {
      try {
        const pageid = token.get('_pageid');
        const x = token.get('left');
        const y = token.get('top');
    
        (playerIds || []).forEach(pid => {
          if (!pid) return;
          // ping tylko do gracza + wymuszenie ‚Äúprzeskoku kamery‚Äù
          // (to jest klucz do centrowania tylko wybranym)
          sendPing(x, y, pageid, pid, true);
        });
      } catch (e) { /* ignore */ }
    };
    
    const getAutoCenterTargetsForToken = (token) => {
      // ignorujemy kontroler√≥w tokenu: centrowaƒá ma ka≈ºdemu kto ma ON
      return findObjs({ type: 'player' })
        .filter(p => p && p.id)
        .map(p => p.id)
        .filter(pid => isAutoCenterEnabledForPlayer(pid));
    };
  // ============================================================
  // STACKING UPSERT (for both built-in and custom)
  // same name -> overwrite only if new rounds > old
  // ============================================================
  const upsertEffectWithStackRule = (token, condKey, rounds, markerTag, isCustom, note) => {
    const rNew = Math.max(1, parseInt(rounds, 10) || 1);
    const effects = getTokenEffects(token.id);

    const idx = effects.findIndex(e => e.condKey === condKey);
    if (idx !== -1) {
      const existing = effects[idx];
      const rOld = Math.max(1, parseInt(existing.rounds, 10) || 1);

      if (rNew > rOld) {
        const newTag = existing.markerTag || markerTag || null;
        const noteNew = String(note || '').trim();
            effects[idx] = {
              ...existing,
              rounds: rNew,
              markerTag: newTag,
              isCustom: !!existing.isCustom,
              note: noteNew ? noteNew : (existing.note || '')
            };
        setTokenEffects(token.id, effects);
        if (newTag) upsertMarkerCountdown(token, newTag, rNew);
        return { ok: true, didUpdate: true, stacked: true };
      }

      return { ok: true, didUpdate: false, stacked: true };
    }

    const tag = markerTag || null;
    effects.push({
      condKey,
      markerTag: tag,
      rounds: rNew,
      isCustom: !!isCustom,
      note: String(note || '').trim()
    });
    setTokenEffects(token.id, effects);
    if (tag) upsertMarkerCountdown(token, tag, rNew);
    return { ok: true, didUpdate: true, stacked: false };
  };

  // ---------- ADD EFFECT (built-in) ----------
  const addEffect = (token, condKey, rounds) => {
    const cond = CONDITIONS.find(c => c.key === condKey);
    if (!cond) return { ok: false, msg: `Unknown condition: ${condKey}` };

    const marker = findMarkerByName(cond.markerName);
    const markerTag = marker ? marker.tag : null;

    return upsertEffectWithStackRule(token, condKey, rounds, markerTag, false);
  };
  
  const getWhisperName = (msg) => {
      const p = getObj('player', msg.playerid);
      const dn = p ? (p.get('_displayname') || p.get('displayname')) : msg.who;
      return String(dn || msg.who || 'GM');
    };

    const whisperPrefix = (msg) => `/w "${getWhisperName(msg)}" `;

  // ---------- ADD CUSTOM EFFECT ----------
    const addCustomEffect = (token, name, markerTag, rounds, note) => {
      const safeName = String(name || '').trim().slice(0, 40) || 'Effect';
      const tag = (markerTag && markerTag !== 'none') ? String(markerTag).trim() : null;
      const safeNote = String(note || '').trim().slice(0, 200); // limit, ≈ºeby nie robiƒá ≈õciany tekstu
    
      return upsertEffectWithStackRule(token, safeName, rounds, tag, true, safeNote);
    };
  
    const getConditionMarkerTagSet = () => {
      const s = new Set();
      CONDITIONS.forEach(c => {
        const m = findMarkerByName(c.markerName);
        if (m && m.tag) s.add(String(m.tag));
      });
      return s;
    };

  // ---------- REMOVE EFFECT (works for built-in + custom) ----------
  const removeEffect = (token, condKey) => {
    const effects = getTokenEffects(token.id);
    if (!effects.length) return;

    const removed = effects.filter(e => e.condKey === condKey);
    if (!removed.length) return;

    const remaining = effects.filter(e => e.condKey !== condKey);
    setTokenEffects(token.id, remaining);

    const removedTags = [...new Set(removed.map(e => e.markerTag).filter(Boolean))];
    removedTags.forEach(tag => recomputeMarkerForTag(token, tag));
  };

  // ---------- SET DURATION ----------
  const setEffectDuration = (token, condKey, newRounds) => {
    const effects = getTokenEffects(token.id);
    const idx = effects.findIndex(e => e.condKey === condKey);
    if (idx === -1) return { ok: false, msg: 'Effect not found.' };

    const n = parseInt(newRounds, 10);
    if (!Number.isFinite(n)) return { ok: false, msg: 'Invalid duration value.' };

    if (n <= 0) {
      const tag = effects[idx].markerTag;
      removeEffect(token, condKey);
      if (tag) recomputeMarkerForTag(token, tag);
      return { ok: true, removed: true };
    }

    effects[idx] = { ...effects[idx], rounds: n };
    setTokenEffects(token.id, effects);

    const tag = effects[idx].markerTag;
    if (tag) recomputeMarkerForTag(token, tag);

    return { ok: true, removed: false };
  };

  // ---------- Decrement effects ----------
  const decrementEffectsForToken = (token) => {
    const effects = getTokenEffects(token.id);
    if (!effects.length) return;

    const next = [];
    effects.forEach(e => {
      const r = (parseInt(e.rounds, 10) || 0) - 1;
      if (r > 0) next.push({ ...e, rounds: r });
    });
    setTokenEffects(token.id, next);

    const oldTags = new Set(effects.map(e => e.markerTag).filter(Boolean));
    const newTags = new Set(next.map(e => e.markerTag).filter(Boolean));

    oldTags.forEach(tag => {
      if (!newTags.has(tag)) removeMarkerTag(token, tag);
      else recomputeMarkerForTag(token, tag);
    });
  };

  // ---------- REMINDERS (only built-in) ----------
  const buildReminders = (effects) => {
    const lines = [];
    effects.forEach(e => {
      const cond = CONDITIONS.find(c => c.key === e.condKey);
      if (!cond || !cond.reminders) return;
      cond.reminders.forEach(r => lines.push({ condKey: e.condKey, text: r }));
    });

    effects.forEach(e => {
      const note = String(e.note || '').trim();
      if (e.isCustom && note) {
        lines.push({ condKey: e.condKey, text: note });
      }
    });

    const seen = new Set();
    return lines.filter(x => {
      const k = `${x.condKey}::${x.text}`;
      if (seen.has(k)) return false;
      seen.add(k);
      return true;
    });
  };

  // ============================================================
  // TURN PANEL (public)
  // ============================================================
  const renderTurnPanel = (token, opts) => {
    opts = opts || {};
    const isShow = !!opts.isShow; // show panel (poza turƒÖ)
    const st = getState();
    const effects = getTokenEffects(token.id);

    const controllers = getTokenControllers(token)
      .map(id => getObj('player', id))
      .filter(p => p && !p.get('is_gm'));
    
    const isEnemy = controllers.length === 0;
    
    const tier = getEnemyTier(token);
    
    const title = isEnemy
      ? (
          tier === 'boss'
            ? `<span style="color:#ff6b6b;font-weight:900;">Boss üíÄüíÄüíÄ</span>`
            : tier === 'miniboss'
              ? `<span style="color:#ff6b6b;font-weight:900;">Mini Boss üíÄüíÄ</span>`
              : `<span style="color:#ff6b6b;font-weight:900;">Enemy üíÄ</span>`
        )
      : esc(getTokenDisplayName(token));

    const img = getTokenImg(token);

    const rows = effects.length
      ? effects.map(e => {
          const gearBtn = `<a title="Edit duration"
            style="display:inline-block;padding:4px 8px;border:1px solid #3b3b3b;border-radius:8px;background:#202028;color:#fff;text-decoration:none;font-weight:900;font-size:12px;margin-right:6px;"
            href="!uca --setduration --token ${token.id} --cond ${encodeURIComponent(e.condKey)} --val ?{New duration for ${e.condKey} (0=remove)|${e.rounds}}">‚öôÔ∏è</a>`;

          const removeBtn = `<a title="Remove effect"
            style="display:inline-block;padding:4px 8px;border:1px solid #3b3b3b;border-radius:8px;background:#2a2020;color:#fff;text-decoration:none;font-weight:900;font-size:12px;"
            href="!uca --removeone --token ${token.id} --cond ${encodeURIComponent(e.condKey)}">üóëÔ∏è</a>`;

          return `<tr>
            <td style="padding:6px 0;border-top:1px solid #2f2f2f;">
              <span style="font-weight:900;color:#fff;">${esc(e.condKey)}</span>
              <span style="color:#bdbdbd;"> ‚Äî ${esc(e.rounds)} rnd</span>
            </td>
            <td style="padding:6px 0;border-top:1px solid #2f2f2f;text-align:right;white-space:nowrap;">
              ${gearBtn}${removeBtn}
            </td>
          </tr>`;
        }).join('')
      : `<tr>
           <td colspan="2" style="padding:6px 0;color:#bdbdbd;">
             No timed effects.
           </td>
         </tr>`;

    const reminders = buildReminders(effects);
    const reminderBlock = reminders.length
      ? `
        <div style="height:1px;background:#2f2f2f;margin:10px 0 8px 0;"></div>
        <div style="font-size:12px;color:#bdbdbd;margin-bottom:6px;font-weight:900;">Reminders</div>
        <ul style="margin:0;padding-left:18px;font-size:12.5px;color:#d0d0d0;line-height:1.35;">
          ${reminders.map(r => `<li><b>${esc(r.condKey)}:</b> ${esc(r.text)}</li>`).join('')}
        </ul>
      `
      : '';

    const endBtn = isShow ? '' : `<a style="display:inline-block;padding:8px 10px;border:1px solid #3b3b3b;border-radius:10px;background:#202028;color:#fff;text-decoration:none;font-weight:900;"
      href="!uca --endturn --token ${token.id} --nonce ${st.turnNonce}">End Turn</a>`;

    const addCustomBtn = `<a title="Add custom effect"
      style="display:inline-block;padding:2px 8px;border:1px solid #2f5f2f;border-radius:8px;background:#1f3b1f;color:#d6ffd6;text-decoration:none;font-weight:900;font-size:14px;line-height:18px;"
      href="!uca --custom --token ${token.id}">Ôºã</a>`;

    const html = `
      <div style="background:#151515;border:1px solid #3b3b3b;border-radius:12px;padding:10px;max-width:640px;">
        <table style="width:100%;border-collapse:collapse;">
          <tr>
            <td style="width:56px;vertical-align:top;">
              <img src="${img}" style="width:48px;height:48px;border-radius:10px;border:1px solid #3b3b3b;display:block;" />
            </td>
            <td style="vertical-align:top;">
              <div style="font-size:16px;font-weight:900;color:#ffffff;line-height:1.15;margin-bottom:2px;">${isShow ? '' : 'Turn: '}${title}</div>
              <div style="font-size:12px;color:#bdbdbd;">${SCRIPT} v${VERSION}</div>
            </td>
          </tr>
        </table>

        <div style="height:1px;background:#2f2f2f;margin:10px 0 8px 0;"></div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
          <div style="font-size:12px;color:#bdbdbd;font-weight:900;">Timed Effects</div>
          <div>${addCustomBtn}</div>
        </div>
        <table style="width:100%;border-collapse:collapse;font-size:12.5px;">
          ${rows}
        </table>

        ${reminderBlock}

        ${isShow ? '' : `<div style="height:1px;background:#2f2f2f;margin:10px 0 10px 0;"></div>
        <div style="text-align:center;">${endBtn}</div>`}
      </div>
    `;

    const out = oneLine(html);

    if (opts && Array.isArray(opts.whisperTargets) && opts.whisperTargets.length) {
      opts.whisperTargets.forEach(prefix => {
        sendChat('UltimateCombatAssistant', `${prefix}${out}`);
      });
    } else {
      sendChat('UltimateCombatAssistant', `/direct ${out}`);
    }
  };

  // ============================================================
  // GM PANEL (+ Clear All)
  // ============================================================
  const renderGmConditionPanel = () => {
    const markerUrlFor = (markerName) => {
      const m = findMarkerByName(markerName);
      return m ? m.url : '';
    };

    const clearAllBtn = `<a style="display:inline-block;padding:6px 10px;border:1px solid #3b3b3b;border-radius:10px;background:#2a2020;color:#fff;text-decoration:none;font-weight:900;"
      href="!uca --clearall">Clear All</a>`;
      
    const startFightBtn = `<a style="display:inline-block;padding:6px 12px;border:1px solid #3b3b3b;border-radius:10px;background:#1f3b1f;color:#fff;text-decoration:none;font-weight:900;"
      href="!uca --startfight">Start Fight</a>`;

    const rows = CONDITIONS.map(c => {
      const icon = markerUrlFor(c.markerName);
      const iconHtml = icon
        ? `<img src="${icon}" style="width:20px;height:20px;border-radius:6px;border:1px solid #3b3b3b;vertical-align:middle;" />`
        : `<span style="display:inline-block;width:20px;height:20px;border-radius:6px;border:1px solid #3b3b3b;background:#2a2a2a;vertical-align:middle;"></span>`;

      const applyBtn = `<a style="display:inline-block;padding:4px 8px;border:1px solid #3b3b3b;border-radius:8px;background:#202028;color:#fff;text-decoration:none;font-weight:900;"
         href="!uca --apply --cond ${encodeURIComponent(c.key)} --rounds ?{Rounds for ${c.key}|1}">Apply</a>`;

      const removeBtn = `<a style="display:inline-block;padding:4px 8px;border:1px solid #3b3b3b;border-radius:8px;background:#2a2020;color:#fff;text-decoration:none;font-weight:900;margin-left:6px;"
         href="!uca --remove --cond ${encodeURIComponent(c.key)}">Remove</a>`;

      return `<tr>
        <td style="padding:6px 0;border-top:1px solid #2f2f2f;white-space:nowrap;">${iconHtml}</td>
        <td style="padding:6px 8px;border-top:1px solid #2f2f2f;color:#fff;font-weight:900;">${esc(c.key)}</td>
        <td style="padding:6px 0;border-top:1px solid #2f2f2f;text-align:right;white-space:nowrap;">${applyBtn}${removeBtn}</td>
      </tr>`;
    }).join('');

    const html = `
      <div style="background:#151515;border:1px solid #3b3b3b;border-radius:12px;padding:10px;max-width:820px;">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
          <div style="font-size:16px;font-weight:900;color:#fff;">UltimateCombatAssistant ‚Äî Conditions (GM)</div>
          <div style="display:flex;gap:18px;align-items:center;">
            ${startFightBtn}
            ${clearAllBtn}
          </div>
        </div>
        <div style="font-size:12px;color:#bdbdbd;margin:6px 0 10px 0;">
          Select token(s), then Apply (with rounds). Stacking: overwrites only if new duration is longer.
        </div>
        <table style="width:100%;border-collapse:collapse;font-size:12.5px;">
          ${rows}
        </table>
      </div>
    `;
    sendChat('UltimateCombatAssistant', `/w gm ${oneLine(html)}`);
  };

  const announceConditionApplied = (token, condKey, rounds, didUpdate) => {
    const cond = CONDITIONS.find(c => c.key === condKey);
    const who = esc(getTokenDisplayName(token));
    const r = parseInt(rounds, 10) || 1;

    const lines = (cond && cond.desc) ? cond.desc : [];
    const li = lines.map(x => `<li style="margin:2px 0;">${esc(x)}</li>`).join('');

    const note = didUpdate ? '' : `<div style="margin-top:8px;font-size:12px;color:#bdbdbd;"><i>Not updated (existing duration is longer or equal).</i></div>`;

    const html = `
      <div style="background:#151515;border:1px solid #3b3b3b;border-radius:12px;padding:10px;max-width:820px;">
        <div style="font-size:15px;font-weight:900;color:#fff;margin-bottom:6px;">${who} ‚Äî ${esc(condKey)} (${r} rnd)</div>
        <ul style="margin:0;padding-left:18px;font-size:12.5px;color:#d0d0d0;line-height:1.35;">
          ${li}
        </ul>
        ${note}
      </div>
    `;
    sendChat('UltimateCombatAssistant', `/direct ${oneLine(html)}`);
  };

  // ============================================================
  // TURN CHANGE
  // ============================================================
  const hashTurnOrder = (order) => {
    try { return JSON.stringify(order || []); } catch (e) { return ''; }
  };

  const onTurnOrderChanged = () => {
    const st = getState();
    const order = readTurnOrder();
    const h = hashTurnOrder(order);
    if (st.lastTurnOrderHash === h) return;
    st.lastTurnOrderHash = h;

    const currentToken = getCurrentTurnToken();
    if (!currentToken) return;

    if (st.lastTurnTokenId && st.lastTurnTokenId !== currentToken.id) {
      const prevTok = getObj('graphic', st.lastTurnTokenId);
      if (prevTok) decrementEffectsForToken(prevTok);
    }

    if (st.lastTurnTokenId !== currentToken.id) {
      st.turnNonce = (st.turnNonce || 0) + 1;
    }

    st.lastTurnTokenId = currentToken.id;
    
    // 1) globalny ping dla wszystkich (znacznik widoczny dla ka≈ºdego)
    pingTokenToEveryone(currentToken);
    
    // 2) centrowanie tylko dla tych co majƒÖ ON
    const targets = getAutoCenterTargetsForToken(currentToken);
    centerTokenForPlayers(currentToken, targets);
    
    renderTurnPanel(currentToken, { viewerPlayerId: null });
  };

  // ============================================================
  // COMMANDS
  // ============================================================
  const parseArgs = (content) => {
    const parts = content.split(/\s+--/).map(s => s.trim()).filter(Boolean);
    const cmd = parts.shift() || '';
    const out = { cmd };
    parts.forEach(p => {
      const i = p.indexOf(' ');
      if (i === -1) out[p] = true;
      else {
        const k = p.slice(0, i).trim();
        const v = decodeURIComponent(p.slice(i + 1).trim());
        out[k] = v;
      }
    });
    return out;
  };
  
    const cmdAutoCenter = (msg, args) => {
      const st = getState();
      st.autocenterByPlayer = st.autocenterByPlayer || {};
    
      let nextVal;
      if (args.on) nextVal = true;
      else if (args.off) nextVal = false;
      else {
        // --toggle albo brak -> toggle
        const cur = isAutoCenterEnabledForPlayer(msg.playerid);
        nextVal = !cur;
      }
    
      st.autocenterByPlayer[msg.playerid] = !!nextVal;
    
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}[UCA] Auto-center is now: <b>${nextVal ? 'ON' : 'OFF'}</b>.`);
    };
  
    const cmdShow = (msg, args) => {
      let token = null;
    
      const tokenIdFromArgs = String(args.token || '').trim();
      if (tokenIdFromArgs) {
        const t = getObj('graphic', tokenIdFromArgs);
        if (t && t.get('subtype') === 'token') token = t;
      } else {
        const selected = getSelectedTokens(msg);
        if (selected.length !== 1) {
          sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}Select exactly ONE token, then run <b>!uca --show</b>.`);
          return;
        }
        token = selected[0];
      }
    
      if (!token) return;
    
      if (!canPlayerControlToken(msg.playerid, token)) {
        sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}You don‚Äôt control this token.`);
        return;
      }
    
      // ZAWSZE tylko do osoby, kt√≥ra wywo≈Ça≈Ça komendƒô (bez kopii do GM)
      const uniqueTargets = [whisperPrefix(msg)];
    
      renderTurnPanel(token, {
        isShow: true,
        viewerPlayerId: msg.playerid,
        whisperTargets: uniqueTargets
      });
    };
  
  const cmdStartFight = (msg) => {
      if (!playerIsGM(msg.playerid)) return;
    
      const cur = getCurrentTurnToken();
      if (!cur) {
        sendChat('UltimateCombatAssistant', `/w gm [UCA] Turn order is empty or current entry is invalid.`);
        return;
      }
    
      // poka≈º panel tury dla aktualnego tokenu
      renderTurnPanel(cur);
    };

  const getSelectedTokens = (msg) => {
    const sel = msg.selected || [];
    return sel
      .map(s => getObj('graphic', s._id))
      .filter(t => t && t.get('subtype') === 'token');
  };

  // ---------- END TURN ----------
  const cmdEndTurn = (msg, args) => {
    const st = getState();
    const cur = getCurrentTurnToken();
    if (!cur) return;

    const tokenFromBtn = String(args.token || '').trim();
    if (!tokenFromBtn || tokenFromBtn !== cur.id) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} This End Turn button is no longer valid.`);
      return;
    }

    const nonceFromBtn = parseInt(args.nonce, 10);
    if (!nonceFromBtn || nonceFromBtn !== st.turnNonce) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} This End Turn button has expired.`);
      return;
    }

    if (!canPlayerControlToken(msg.playerid, cur)) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} You don‚Äôt control the current turn token.`);
      return;
    }

    const order = readTurnOrder();
    if (!order.length) return;
    const first = order.shift();
    order.push(first);
    writeTurnOrder(order);

    st.lastTurnOrderHash = null;
    onTurnOrderChanged();
  };

  // ---------- APPLY / REMOVE (GM) ----------
  const cmdApply = (msg, args) => {
    if (!playerIsGM(msg.playerid)) return;

    const cond = (args.cond || '').trim();
    const rounds = args.rounds || '1';
    if (!cond) return;

    let tokens = [];
    
    const tokenIdFromArgs = String(args.token || '').trim();
    if (tokenIdFromArgs) {
      const t = getObj('graphic', tokenIdFromArgs);
      if (t && t.get('subtype') === 'token') tokens = [t];
    } else {
      tokens = getSelectedTokens(msg);
    }
    
    if (!tokens.length) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}Select token(s) first, then run <b>!uca --custom</b>.`);
      return;
    }
    
    // uprawnienia: GM zawsze, gracze tylko je≈õli kontrolujƒÖ WSZYSTKIE wskazane tokeny
    if (!playerIsGM(msg.playerid)) {
      const ok = tokens.every(t => canPlayerControlToken(msg.playerid, t));
      if (!ok) {
        sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}You don‚Äôt control one or more of the target tokens.`);
        return;
      }
    }

    tokens.forEach(t => {
      const res = addEffect(t, cond, rounds);
      if (res.ok) announceConditionApplied(t, cond, rounds, res.didUpdate);
      else sendChat('UltimateCombatAssistant', `/w gm ${res.msg}`);
    });

    const cur = getCurrentTurnToken();
    if (cur && tokens.some(t => t.id === cur.id)) renderTurnPanel(cur);
  };

  const cmdRemove = (msg, args) => {
    if (!playerIsGM(msg.playerid)) return;

    const cond = (args.cond || '').trim();
    if (!cond) return;

    const tokens = getSelectedTokens(msg);
    if (!tokens.length) {
      sendChat('UltimateCombatAssistant', `/w gm Select token(s), then Remove.`);
      return;
    }

    tokens.forEach(t => removeEffect(t, cond));

    const cur = getCurrentTurnToken();
    if (cur && tokens.some(t => t.id === cur.id)) renderTurnPanel(cur);
  };

  // ---------- REMOVE ONE (owner/gm) ----------
  const cmdRemoveOne = (msg, args) => {
    const tokenId = String(args.token || '').trim();
    const cond = String(args.cond || '').trim();
    if (!tokenId || !cond) return;

    const token = getObj('graphic', tokenId);
    if (!token) return;

    if (!canPlayerControlToken(msg.playerid, token)) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} You don‚Äôt control this token.`);
      return;
    }

    removeEffect(token, cond);

    const cur = getCurrentTurnToken();
    if (cur && cur.id === token.id) renderTurnPanel(cur);
  };

  // ---------- SET DURATION (gear button) ----------
  const cmdSetDuration = (msg, args) => {
    const tokenId = String(args.token || '').trim();
    const cond = String(args.cond || '').trim();
    const val = String(args.val || '').trim();
    if (!tokenId || !cond) return;

    const token = getObj('graphic', tokenId);
    if (!token) return;

    if (!canPlayerControlToken(msg.playerid, token)) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} You don‚Äôt control this token.`);
      return;
    }

    const res = setEffectDuration(token, cond, val);
    if (!res.ok) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} ${res.msg || 'Failed.'}`);
      return;
    }

    const cur = getCurrentTurnToken();
    if (cur && cur.id === token.id) renderTurnPanel(cur);
  };

  // ---------- CUSTOM MENU (players + GM) ----------
const cmdCustomMenu = (msg, args) => {
  let tokens = [];

  // 1) je≈õli przysz≈Ço --token, to cel = TEN token (ignorujemy selekcjƒô)
  const tokenIdFromArgs = String(args.token || '').trim();
  if (tokenIdFromArgs) {
    const t = getObj('graphic', tokenIdFromArgs);
    if (t && t.get('subtype') === 'token') tokens = [t];
  } else {
    // 2) fallback: selekcja
    tokens = getSelectedTokens(msg);
  }

  if (!tokens.length) {
    sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}Select token(s) first, then run <b>!uca --custom</b>.`);
    return;
  }

  // uprawnienia: GM zawsze, gracze tylko je≈õli kontrolujƒÖ WSZYSTKIE targety
  if (!playerIsGM(msg.playerid)) {
    const ok = tokens.every(t => canPlayerControlToken(msg.playerid, t));
    if (!ok) {
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}You don‚Äôt control one or more of the target tokens.`);
      return;
    }
  }

  const tokenIdsCsv = tokens.map(t => t.id).join(',');

  const forbidden = getConditionMarkerTagSet();
  const markers = getMarkerCatalog()
    .filter(m => m && m.tag && m.url)
    .filter(m => !forbidden.has(String(m.tag)))
    .slice()
    .sort((a, b) => String(a.name || '').localeCompare(String(b.name || ''), 'en'));

  const pageSize = 18;
  const page = Math.max(1, parseInt(args.page || '1', 10) || 1);
  const pages = Math.max(1, Math.ceil(markers.length / pageSize));
  const p = Math.min(page, pages);

  const slice = markers.slice((p - 1) * pageSize, (p - 1) * pageSize + pageSize);

  const mkCell = (m) => {
        const tag = encodeURIComponent(m.tag);
        const nameLbl = esc(String(m.name || m.tag));
        const img = esc(m.url);
    
        const link = `!uca --addcustom --tokens ${tokenIdsCsv} --tag ${tag} --name ?{Effect name|} --note ?{Optional description (blank=none)|} --rounds ?{Rounds|1}`;
    
        return `
          <td style="width:12.5%;padding:6px;text-align:center;vertical-align:top;">
            <a href="${link}" style="text-decoration:none;display:inline-block;">
              <img src="${img}" title="${nameLbl}"
                   style="width:26px;height:26px;border-radius:6px;border:1px solid #3b3b3b;display:block;margin:0 auto 4px auto;" />
              <div style="font-size:10.5px;line-height:1.15;color:#d0d0d0;max-width:90px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0 auto;">
                ${nameLbl}
              </div>
            </a>
          </td>
        `;
      };
    
      const cols = 3;
      const rows = [];
      for (let i = 0; i < slice.length; i += cols) {
        const rowCells = slice.slice(i, i + cols).map(mkCell).join('');
        const missing = cols - slice.slice(i, i + cols).length;
        const pad = missing > 0 ? '<td></td>'.repeat(missing) : '';
        rows.push(`<tr>${rowCells}${pad}</tr>`);
      }
    
      const noneLink = `!uca --addcustom --tokens ${tokenIdsCsv} --tag none --name ?{Effect name|} --note ?{Optional description (blank=none)|} --rounds ?{Rounds|1}`;
    
      const prevBtn = p > 1
        ? `<a style="display:inline-block;padding:6px 10px;border:1px solid #3b3b3b;border-radius:10px;background:#202028;color:#fff;text-decoration:none;font-weight:900;"
              href="!uca --custom ${tokenIdFromArgs ? `--token ${tokenIdFromArgs} ` : ''}--page ${p - 1}">‚óÄ Prev</a>`
        : `<span style="display:inline-block;padding:6px 10px;border:1px solid #333;border-radius:10px;background:#111;color:#666;font-weight:900;">‚óÄ Prev</span>`;
    
      const nextBtn = p < pages
        ? `<a style="display:inline-block;padding:6px 10px;border:1px solid #3b3b3b;border-radius:10px;background:#202028;color:#fff;text-decoration:none;font-weight:900;"
              href="!uca --custom ${tokenIdFromArgs ? `--token ${tokenIdFromArgs} ` : ''}--page ${p + 1}">Next ‚ñ∂</a>`
        : `<span style="display:inline-block;padding:6px 10px;border:1px solid #333;border-radius:10px;background:#111;color:#666;font-weight:900;">Next ‚ñ∂</span>`;
    
      const html = `
        <div style="background:#151515;border:1px solid #3b3b3b;border-radius:12px;padding:10px;max-width:920px;">
          <div style="font-size:14px;font-weight:900;color:#fff;margin-bottom:6px;">Add Custom Effect</div>
          <div style="font-size:12px;color:#bdbdbd;margin-bottom:8px;">
            Target: <b>${tokens.length}</b> token(s).<br>
            Click an icon ‚Üí you‚Äôll be asked for effect name + rounds ‚Üí it applies.
          </div>
    
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px;">
            <div style="font-size:12px;color:#bdbdbd;">Icon page <b>${p}</b>/<b>${pages}</b> (total: ${markers.length})</div>
            <div style="display:flex;gap:8px;align-items:center;">
              ${prevBtn}
              ${nextBtn}
              <a style="display:inline-block;padding:6px 10px;border:1px solid #3b3b3b;border-radius:10px;background:#2a2020;color:#fff;text-decoration:none;font-weight:900;"
                 href="${noneLink}">No Icon</a>
            </div>
          </div>
    
          <table style="width:100%;border-collapse:collapse;">
            ${rows.join('')}
          </table>
    
          <div style="margin-top:8px;font-size:11.5px;color:#777;">
            Tip: If you have many markers, use Prev/Next.
          </div>
        </div>
      `;
    
      sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}${oneLine(html)}`);
    };


    const cmdAddCustom = (msg, args) => {
      const tokensCsv = String(args.tokens || '').trim();
      const name = String(args.name || '').trim();
      const tag = String(args.tag || '').trim();
      const rounds = String(args.rounds || '1').trim();
      const note = String(args.note || '').trim();
    
      if (!tokensCsv) return;
    
      const tokenIds = tokensCsv.split(',').map(s => s.trim()).filter(Boolean);
      if (!tokenIds.length) return;
    
      // Pobierz tokeny i odfiltruj nieistniejƒÖce
      const tokens = tokenIds
        .map(tid => getObj('graphic', tid))
        .filter(t => t && t.get('subtype') === 'token');
    
      if (!tokens.length) return;
    
      // Uprawnienia: GM zawsze; gracz tylko je≈õli kontroluje WSZYSTKIE targety
      if (!playerIsGM(msg.playerid)) {
        const ok = tokens.every(t => canPlayerControlToken(msg.playerid, t));
        if (!ok) {
          sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)}You don‚Äôt control one or more of the target tokens.`);
          return;
        }
      }
    
      // Apply
      tokens.forEach(token => {
        addCustomEffect(token, name, tag, rounds, note);
    
        const cur = getCurrentTurnToken();
        if (cur && cur.id === token.id) renderTurnPanel(cur);
      });
    
      sendChat('UltimateCombatAssistant', `${whisperTo(msg.playerid)}[UCA] Custom effect added to ${tokens.length} token(s).`);
    };

  // ---------- CLEAR ALL (GM) ----------
  const cmdClearAll = (msg) => {
    if (!playerIsGM(msg.playerid)) return;

    const st = getState();
    const tokenIds = Object.keys(st.effectsByToken || {});

    tokenIds.forEach(tid => {
      const tok = getObj('graphic', tid);
      if (!tok) return;
      const eff = st.effectsByToken[tid] || [];
      const tags = [...new Set(eff.map(e => e.markerTag).filter(Boolean))];
      tags.forEach(tag => removeMarkerTag(tok, tag));
    });

    st.effectsByToken = {};
    writeTurnOrder([]);

    st.lastTurnTokenId = null;
    st.lastTurnOrderHash = null;
    st.turnNonce = (st.turnNonce || 0) + 1;

    sendChat('UltimateCombatAssistant', `/w gm [UCA] Cleared all effects and cleared the entire turn order.`);
  };

  // ---------- PANEL ----------
  const cmdPanel = (msg) => {
    if (!playerIsGM(msg.playerid)) return;
    renderGmConditionPanel();
  };

  // ============================================================
  // CHAT HANDLER
  // ============================================================
  const handleChat = (msg) => {
    if (msg.type !== 'api') return;
    if (!msg.content.startsWith('!uca')) return;

    const args = parseArgs(msg.content);

    if (args.panel) return cmdPanel(msg);

    if (args.custom) return cmdCustomMenu(msg, args);
    if (args.addcustom) return cmdAddCustom(msg, args);

    if (args.clearall) return cmdClearAll(msg);

    if (args.endturn) return cmdEndTurn(msg, args);
    if (args.apply) return cmdApply(msg, args);
    if (args.remove) return cmdRemove(msg, args);
    if (args.removeone) return cmdRemoveOne(msg, args);
    if (args.setduration) return cmdSetDuration(msg, args);
    if (args.startfight) return cmdStartFight(msg);
    if (args.show) return cmdShow(msg, args);
    if (args.autocenter) return cmdAutoCenter(msg, args);

    sendChat('UltimateCombatAssistant', `${whisperPrefix(msg)} <div style="background:#111;border:1px solid #444;padding:8px;border-radius:8px;">
      <b>${SCRIPT} v${VERSION}</b><br><br>
      <b>!uca --panel</b> ‚Äî GM conditions panel<br>
      <b>!uca --custom</b> ‚Äî custom timed effect (GM: multi-select OK, Players: 1 controlled token)<br>
      <b>!uca --show</b> ‚Äî show your panel outside your turn (no End Turn)
      <b>!uca --autocenter --on</b> ‚Äî enable auto-center for you<br>
      <b>!uca --autocenter --off</b> ‚Äî disable auto-center for you<br>
      <b>!uca --autocenter</b> / <b>!uca --autocenter --toggle</b> ‚Äî toggle auto-center<br>
      <b>‚öôÔ∏è</b> on turn panel ‚Äî edit duration (0 removes)<br>
    </div>`);
  };

  const handleTurnOrderChange = () => onTurnOrderChanged();

  const checkInstall = () => {
    const st = getState();
    st.version = VERSION;
    sendChat('UltimateCombatAssistant', `/w gm ${SCRIPT} v${VERSION} ready. GM command: !uca --panel`);
  };

  const register = () => {
    on('chat:message', handleChat);
    on('change:campaign:turnorder', handleTurnOrderChange);
  };

  return { checkInstall, register };
})();

on('ready', () => {
  'use strict';
  UltimateCombatAssistantByZrujnowany.checkInstall();
  UltimateCombatAssistantByZrujnowany.register();
});
